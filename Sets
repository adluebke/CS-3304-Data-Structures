/*
* Class: CS 3304/07
* Term: Fall 2016
* Name: Andrew Luebke
* Instructor: Monisha Verma
* HW Assignment 3
*/
// FILE: set1.h
// CLASS PROVIDED: set (part of the namespace main_savitch_3)
//
// TYPEDEF and MEMBER CONSTANTS for the set class:
//   typedef ____ value_type
//     set::value_type is the data type of the items in the set. It may be any of
//     the C++ built-in types (int, char, etc.), or a class with a default
//     constructor, an assignment operator, and operators to
//     test for equality (x == y) and non-equality (x != y).
//
//   typedef ____ size_type
//     set::size_type is the data type of any variable that keeps track of how many items
//     are in a set.
//
//   static const size_type CAPACITY = _____
//     set::CAPACITY is the maximum number of items that a set can hold.
//
// CONSTRUCTOR for the set class:
//   set( )
//     Postcondition: The set has been initialized as an empty set.
//
// MODIFICATION MEMBER FUNCTIONS for the set class:
//   size_type erase(const value_type& target);
//     Postcondition: All copies of target have been removed from the set.
//     The return value is the number of copies removed (which could be zero).
//
//   void erase_one(const value_type& target)
//     Postcondition: If target was in the set, then one copy has been removed;
//     otherwise the set is unchanged. A true return value indicates that one
//     copy was removed; false indicates that nothing was removed.
//
//   void insert(const value_type& entry)
//     Precondition:  size( ) < CAPACITY.
//     Postcondition: A new copy of entry has been added to the set.
//
//   void operator +=(const set& addend)
//     Precondition:  size( ) + addend.size( ) <= CAPACITY.
//     Postcondition: Each item in addend has been added to this set.
//
// CONSTANT MEMBER FUNCTIONS for the set class:
//   size_type size( ) const
//     Postcondition: The return value is the total number of items in the set.
//
//   bool set::contains(const value_type& target) const
//     Postcondition: The return value is true if target is in the set;
//		otherwise the return value is false. 
// NONMEMBER FUNCTIONS for the set class:
//   set operator +(const set& b1, const set& b2)
//     Precondition:  b1.size( ) + b2.size( ) <= set::CAPACITY.
//     Postcondition: The set returned is the union of b1 and b2.
//
// VALUE SEMANTICS for the set class:
//    Assignments and the copy constructor may be used with set objects.

#ifndef MAIN_SAVITCH_SEQUENCE_H
#define MAIN_SAVITCH_SEQUENCE_H

namespace HW_ASSIGNMENT_03_ALUEBKE
{
	class set
	{
	public:	
		// TYPEDEFS and MEMBER CONSTANTS
        typedef int value_type;
        typedef std::size_t size_type;
        static const size_type CAPACITY = 30;
        // CONSTRUCTOR
        set( ) { used = 0; } 
        // MODIFICATION MEMBER FUNCTIONS
        size_type erase(const value_type& target);
        bool erase_one(const value_type& target);
        void insert(const value_type& entry);
        void operator +=(const set& addend);
		void print();
        // CONSTANT MEMBER FUNCTIONS
        size_type size( ) const { return used; }
        bool contains(const value_type& target) const;
    private:
        value_type data[CAPACITY];  // The array to store items
        size_type used;             // How much of array is used
		
	};
}	

#endif

// FILE: set.cxx
// CLASS IMPLEMENTED: set (see set.h for documentation)
// INVARIANT for the set class:
//   1. The number of items in the set is in the member variable used;
//   2. For an empty set, we do not care what is stored in any of data; for a
//      non-empty set the items in the set are stored in data[0] through
//      data[used-1], and we don't care what's in the rest of data.
//   3. In any given set, the same number cannot occur twice.

#include <algorithm> // Provides copy function
#include <cassert>   // Provides assert function
#include <iostream>
#include "set.h"

using namespace std;

namespace HW_ASSIGNMENT_03_ALUEBKE
{
    const set::size_type set::CAPACITY;
    
    set::size_type set::erase(const value_type& target)
    {
		size_type index = 0;
		size_type many_removed = 0;

		while (index < used)
		{
			if (data[index] == target)
			{
			--used;
			data[index] = data[used];
			++many_removed;
			}
			else
			++index;
		}

		return many_removed;
    }

    bool set::erase_one(const value_type& target)
    {
		size_type index; // The location of target in the data array    

		// First, set index to the location of target in the data array,
		// which could be as small as 0 or as large as used-1. If target is not
		// in the array, then index will be set equal to used.
		index = 0; 
		while ((index < used) && (data[index] != target))
			++index;

		if (index == used)
			return false; // target isnâ€™t in the set, so no work to do.

		// When execution reaches here, target is in the set at data[index].
		// So, reduce used by 1 and copy the last item onto data[index].
		--used;
		data[index] = data[used];    
		return true;
    }

    void set::insert(const value_type& entry)
    // Library facilities used: cassert
    {   
        assert(size( ) < CAPACITY);
		
		if (contains(entry))
		{
			cout << "Error! Set cannot have two of the same values." << endl;
			return;
		}
		else
		{
			data[used] = entry;
			++used;	
		}
    }

    void set::operator +=(const set& addend)
    // Library facilities used: algorithm, cassert
    {
	assert(size( ) + addend.size( ) <= CAPACITY);
	
	copy(addend.data, addend.data + addend.used, data + used);
	used += addend.used;
    }

    bool set::contains(const value_type& target) const
    {
        size_type i;

        for (i = 0; i < used; i++)
		{
            if (target == data[i])
			{
				cout << "Error! This is already in the set!" << endl;
				return true;
			}
			else
			{
				return false;
			}
		}
        
    }

    set operator +(const set& b1, const set& b2)
    // Library facilities used: cassert
    {
        set answer;

        assert(b1.size( ) + b2.size( ) <= set::CAPACITY);

        answer += b1; 
        answer += b2;
        return answer;
    }
	
	void set::print() 
	{
		for (int i = used; i--;)
		{
			cout << data[i] << ", ";
		}
		cout << endl;
	}
	
}

#include <algorithm> // Provides copy function
#include <cassert>   // Provides assert function
#include <iostream>
#include "set.h"


using namespace HW_ASSIGNMENT_03_ALUEBKE;
using namespace std;


int main(int argc, char **argv)
{
	set sample1;
	set sample2;
	
	int sample1_inp1;
	int sample1_inp2;
	int sample1_inp3;
	
	int sample2_inp1;
	int sample2_inp2;
	int sample2_inp3;
	
	// Ask user for first set's numbers.
	
	cout << "Please enter first set's FIRST number. " << endl;
	cin >> sample1_inp1;
	
	cout << "Please enter first set's SECOND number. " << endl;
	cin >> sample1_inp2;
	
	cout << "Please enter first set's THIRD number. " << endl;
	cin >> sample1_inp3;
	
	sample1.insert(sample1_inp1);
	sample1.insert(sample1_inp2);
	sample1.insert(sample1_inp3);
	
	// Ask user for second set's numbers.
	
	cout << "Please enter second set's FIRST number. " << endl;
	cin >> sample2_inp1;
	
	cout << "Please enter second set's SECOND number. " << endl;
	cin >> sample2_inp2;
	
	cout << "Please enter second set's THIRD number. " << endl;
	cin >> sample2_inp3;
	
	sample2.insert(sample2_inp1);
	sample2.insert(sample2_inp2);
	sample2.insert(sample2_inp3);
	
	sample1.print();
	sample2.print();
	
	return 0;
}


